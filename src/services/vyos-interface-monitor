#!/usr/bin/env python3

import os
import logging
import signal
import pyudev
import netaddr
import json
import time

from typing import Tuple

from vyos.configtree import ConfigTree
from vyos.configsession import ConfigSession

debug = True

logger = logging.getLogger(__name__)
logs_handler = logging.StreamHandler()
logger.addHandler(logs_handler)

config_path = '/opt/vyatta/etc/config/config.boot'
config_status = '/tmp/vyos-config-status'

interface_mapping = '/opt/vyatta/etc/config/interface.mapping'

if debug:
    logger.setLevel(logging.DEBUG)
else:
    logger.setLevel(logging.INFO)

class MacAddr:
    interface_mapping = {'eth': {}, 'wlan': {}}
    transient_mapping = {'eth': {}, 'wlan': {}}
    netaddr.mac_eui48.word_sep=':'
    def __init__(self, numerical):
        self.mac = netaddr.EUI(numerical)

    def is_multicast(self):
        return bool(self.mac.words[0] & 0b01)

    def is_locally_administered(self):
        return bool(self.mac.words[0] & 0b10)

    def is_on_passlist(self):
        # not yet implemented; need to confirm wl from vyatta_interface_rescan
        return False

    @classmethod
    def update(cls, mapping, mac, intf):
        if not mac or not intf:
            return

        if 'interface' in mapping:
            dict_map = cls.interface_mapping
        if 'transient' in mapping:
            dict_map = cls.transient_mapping

        if 'eth' in intf:
            dict_map['eth'][mac] = intf
        if 'wlan' in intf:
            dict_map['wlan'][mac] = intf

    @classmethod
    def find_and_remove_interface(cls, addr) -> Tuple[str,str]:
        if addr in cls.interface_mapping['eth']:
            intf_type = 'ethernet'
            intf = cls.interface_mapping['eth'].pop(addr)
        if addr in cls.interface_mapping['wlan']:
            intf_type = 'wireless'
            intf = cls.interface_mapping['wlan'].pop(addr)

        return (intf, intf_type)

def boot_configuration_complete():
    if os.path.isfile(config_status):
        return True
    return False

def read_interface_config() -> dict:
    with open(config_path) as f:
        config_file = f.read()
    config = ConfigTree(config_file)

def read_interface_mapping() -> dict:
    try:
        with open(interface_mapping) as f:
            MacAddr.interface_mapping = json.load(f)
    except OSError:
        return False
    else:
        return True

def write_interface_mapping() -> bool:
    try:
        with open(interface_mapping, 'w') as f:
            json.dump(MacAddr.interface_mapping, f)
    except OSError:
        return False
    else:
        return True

def load_interface_mapping() -> bool:
    if read_interface_mapping():
        return True
    if read_interface_config():
        return True
    return False

def load_transient_mapping(context) -> None:
    for device in context.list_devices(subsystem='net'):
        mac = None
        intf = None
        if 'ID_NET_NAME_MAC' in device.properties:
            mac = device.properties['ID_NET_NAME_MAC']
        if 'INTERFACE' in device.properties:
            intf = device.properties['INTERFACE']
        logger.info(f"JSE device: mac {mac} interface {intf}")
        if mac and intf:
            mac = mac[-12:]
            MacAddr.update('transient', mac, intf)

def load_config(config_path: str) -> None:
    if not boot_configuration_complete():
        return
    session = ConfigSession(os.getpid())
    session.load_config(config_path)
    session.commit()

def get_wireless_physical_device(intf: str) -> str:
    if 'wlan' not in intf:
        return None
    tmp = os.readlink(f'/sys/class/net/{intf}/phy80211')
    phy = os.path.basename(tmp)
    print(f"JSE wireless phy is {phy}")
    return phy

def interface_rename(old: str, new: str):
    cmd(f'sudo ip link set {old} down')
    cmd(f'sudo ip link set {old} name {new}')
    cmd(f'sudo ip link set {new} up')

def rationalize(keys: set, stable: dict, proposed: dict):
    rename = []
    for k in keys:
        if stable[k] != proposed[k]:
            rename.append(k)

    return

def remove_interfaces(addrs: set):
    removed_interfaces = []
    for k in addrs:
        removed_interfaces.append(MacAddr.find_and_remove_interface(k))

    write_interface_mapping()

    with open(config_path) as f:
        config_file = f.read()
    config = ConfigTree(config_file)

    for (intf, intf_type) in removed_interfaces:
        config.delete(['interfaces', intf_type, intf])

    with open(config_path, 'w') as f:
        f.write(config.to_string())

    load_config(config_path)

def add_interfaces(addrs: set):
    pass

def update_boot():
    from vyos.configtree import ConfigTree, ConfigTreeError

    with open(config_path) as f:
        config_file = f.read()

    config_tree = ConfigTree(config_file)

    print(f"JSE interface_mapping {MacAddr.interface_mapping}")

    for mac, intf in MacAddr.interface_mapping.items():
        if 'eth' in intf:
            config_tree.set(['interfaces', 'ethernet', intf, 'hw-id'], value=mac)
        if 'wlan' in intf:
            phy = get_wireless_physical_device(intf)
            if phy:
                config_tree.set(['interfaces', 'wireless', intf, 'physical-device'], value=phy)

    try:
        with open(config_path, 'w') as f:
            f.write(config_tree.to_string())
        print("JSE wrote config")
    except OSError as e:
        print("JSE OSError {e}")

def update_live():
    pass

def initialize(context):
    load_interface_mapping()
    load_transient_mapping(context)

    intf_set = set(MacAddr.interface_mapping)
    tran_set = set(MacAddr.transient_mapping)

    intersection = intf_set & tran_set
    to_remove = intf_set - intersection
    to_add = tran_set - intersection

    remove_interfaces(to_remove)
    rationalize(intersection, MacAddr.interface_mapping,
                              MacAddr.transient_mapping)
    add_interfaces(to_add)

    

#    update_boot()

def eth_update(device):
    logger.info(f"JSE eth action {device.action} device {device}")
    logger.info(f"JSE in eth_update, interface_mapping {MacAddr.interface_mapping}")

def wlan_update(device):
    logger.info(f"JSE wlan action {device.action} device {device}")


def main():
    context = pyudev.Context()

    initialize(context)

    monitor = pyudev.Monitor.from_netlink(context)
    monitor.filter_by('net')
    def interface_event(device):
        logger.info(f"JSE in log_event, device is {device}")
        if 'INTERFACE' in device.properties and 'eth' in device.properties['INTERFACE']:
            eth_update(device)
        else:
            logger.info(f"JSE sanity: device.properties['INTERFACE'] {device.properties['INTERFACE']}")
        if 'INTERFACE' in device.properties and 'wlan' in device.properties['INTERFACE']:
            wlan_update(device)
        else:
            logger.info(f"JSE sanity: device.properties['INTERFACE'] {device.properties['INTERFACE']}")

    def sig_handler(signum, frame):
        observer.stop()
        raise KeyboardInterrupt

    signal.signal(signal.SIGTERM, sig_handler)

    observer = pyudev.MonitorObserver(monitor, callback=interface_event)
    observer.start()

#    while True:
#        if os.path.isfile(config_status):
#            # mv file
#            break
#        time.sleep(2)

#    observer.join()
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        logger.info(f"JSE exiting")

#    while True:
#        try:
#            pass
#            logger.info(f"JSE eth_num is {eth_num}")
#            time.sleep(1)
#        except KeyboardInterrupt:
#            logger.info(f"JSE exiting")
#            break

if __name__ == '__main__':
    main()
