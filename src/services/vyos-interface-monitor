#!/usr/bin/env python3

import os
import logging
import signal
import pyudev
import netaddr
import json
import time

from typing import Tuple

from vyos.configtree import ConfigTree
from vyos.configsession import ConfigSession
from vyos.util import cmd

debug = True

logger = logging.getLogger(__name__)
logs_handler = logging.StreamHandler()
logger.addHandler(logs_handler)

config_path = '/opt/vyatta/etc/config/config.boot'
config_status = '/tmp/vyos-config-status'

interface_map = '/opt/vyatta/etc/config/interface.map'

if debug:
    logger.setLevel(logging.DEBUG)
else:
    logger.setLevel(logging.INFO)

class MacAddr:
    interface_mapping = {'eth': {}, 'wlan': {}}
    transient_mapping = {'eth': {}, 'wlan': {}}
    netaddr.mac_eui48.word_sep=':'
    def __init__(self, numerical):
        self.mac = netaddr.EUI(numerical)

    def is_multicast(self):
        return bool(self.mac.words[0] & 0b01)

    def is_locally_administered(self):
        return bool(self.mac.words[0] & 0b10)

    def is_on_passlist(self):
        # not yet implemented; need to confirm wl from vyatta_interface_rescan
        return False

    @classmethod
    def update(cls, mapping, mac, intf):
        if not mac or not intf:
            return

        if 'interface' in mapping:
            dict_map = cls.interface_mapping
        if 'transient' in mapping:
            dict_map = cls.transient_mapping

        if 'eth' in intf:
            dict_map['eth'][mac] = intf
        if 'wlan' in intf:
            dict_map['wlan'][mac] = intf

    @classmethod
    def find_and_remove_interface(cls, addr) -> Tuple[str,str]:
        intf = ''
        intf_type = ''
        if addr in cls.interface_mapping['eth']:
            intf_type = 'ethernet'
            intf = cls.interface_mapping['eth'].pop(addr)
        if addr in cls.interface_mapping['wlan']:
            intf_type = 'wireless'
            intf = cls.interface_mapping['wlan'].pop(addr)

        return (intf, intf_type)

    @classmethod
    def add_interface(cls, addr, intf) -> Tuple[str, str]:
        intf_type = ''
        if 'eth' in intf:
            intf_type = 'ethernet'
            # TODO: consult biosdevname here
            cls.interface_mapping['eth'][addr] = intf
        if 'wlan' in intf:
            intf_type = 'wireless'
            # TODO: check for first available here
            cls.interface_mapping['wlan'][addr] = intf

        return (addr, intf, intf_type)

def boot_configuration_complete():
    if os.path.isfile(config_status):
        return True
    return False

def read_interface_config() -> dict:
    with open(config_path) as f:
        config_file = f.read()
    config = ConfigTree(config_file)
    nodes = config.list_nodes(['interfaces'])
    logger.info(f"JSE nodes: {nodes}")

def read_interface_mapping() -> dict:
    try:
        with open(interface_map) as f:
            MacAddr.interface_mapping = json.load(f)
    except OSError:
        return False
    else:
        return True

def write_interface_mapping() -> bool:
    try:
        with open(interface_map, 'w') as f:
            json.dump(MacAddr.interface_mapping, f)
    except OSError:
        return False
    else:
        return True

def load_interface_mapping() -> bool:
    if read_interface_mapping():
        return True
    if read_interface_config():
        return True
    return False

def load_transient_mapping(context) -> None:
    for device in context.list_devices(subsystem='net'):
        addr = None
        intf = None
        if 'ID_NET_NAME_MAC' in device.properties:
            addr = device.properties['ID_NET_NAME_MAC']
        if 'INTERFACE' in device.properties:
            intf = device.properties['INTERFACE']
        logger.info(f"JSE device: mac {addr} interface {intf}")
        if addr and intf:
            addr = addr[-12:]
            mac = MacAddr(addr)
            mac.update('transient', str(mac.mac), intf)

def load_config(config_path: str) -> None:
    if not boot_configuration_complete():
        return
    session = ConfigSession(os.getpid())
    session.load_config(config_path)
    session.commit()

def get_wireless_physical_device(intf: str) -> str:
    if 'wlan' not in intf:
        return None
    tmp = os.readlink(f'/sys/class/net/{intf}/phy80211')
    phy = os.path.basename(tmp)
    print(f"JSE wireless phy is {phy}")
    return phy

def interface_rename(old: str, new: str):
    cmd(f'sudo ip link set {old} down')
    cmd(f'sudo ip link set {old} name {new}')
    cmd(f'sudo ip link set {new} up')

def rationalize(keys: set, stable: dict, proposed: dict):
    rename = []
    for k in keys:
        if k in stable['eth'] and stable['eth'][k] != proposed['eth'][k]:
            rename.append(k)
        if k in stable['wlan'] and stable['wlan'][k] != proposed['wlan'][k]:
            rename.append(k)

    return

def remove_interfaces(addrs: set):
    removed_interfaces = []
    for k in addrs:
        removed_interfaces.append(MacAddr.find_and_remove_interface(k))

    write_interface_mapping()

    with open(config_path) as f:
        config_file = f.read()
    config = ConfigTree(config_file)

    for (intf, intf_type) in removed_interfaces:
        config.delete(['interfaces', intf_type, intf])

    with open(config_path, 'w') as f:
        f.write(config.to_string())

    load_config(config_path)

def add_interfaces(addr: set):
    eths = MacAddr.transient_mapping['eth']
    wlans = MacAddr.transient_mapping['wlan']
    added_interfaces = []
    for k in addr:
        mac = MacAddr(k)
        if str(mac.mac) in eths:
            # biosdevname(eths[k])
            added_interfaces.append(MacAddr.add_interface(str(mac.mac),
                eths[str(mac.mac)]))
        if str(mac.mac) in wlans:
            added_interfaces.append(MacAddr.add_interface(str(mac.mac),
                wlans[str(mac.mac)]))

    logger.info(f"JSE added_interfaces {added_interfaces}")

    write_interface_mapping()

    with open(config_path) as f:
        config_file = f.read()
    config = ConfigTree(config_file)

    for (addr, intf, intf_type) in added_interfaces:
        if not intf or not intf_type:
            continue
        config.set(['interfaces', intf_type, intf, 'hw-id'], value=addr)
        if intf_type == 'wireless':
            config.set(['interfaces', intf_type, intf, 'physical-device'],
                       value=get_wireless_physical_device(intf))

    with open(config_path, 'w') as f:
        f.write(config.to_string())

    load_config(config_path)

def update_boot():
#    from vyos.configtree import ConfigTree, ConfigTreeError

    with open(config_path) as f:
        config_file = f.read()

    config_tree = ConfigTree(config_file)

    print(f"JSE interface_mapping {MacAddr.interface_mapping}")

    for mac, intf in MacAddr.interface_mapping.items():
        if 'eth' in intf:
            config_tree.set(['interfaces', 'ethernet', intf, 'hw-id'], value=mac)
        if 'wlan' in intf:
            phy = get_wireless_physical_device(intf)
            if phy:
                config_tree.set(['interfaces', 'wireless', intf, 'physical-device'], value=phy)

    try:
        with open(config_path, 'w') as f:
            f.write(config_tree.to_string())
        print("JSE wrote config")
    except OSError as e:
        print("JSE OSError {e}")

def update_live():
    pass

def initialize(context):
    if not load_interface_mapping():
        logger.critical("JSE load_interface_mapping() failed")
    load_transient_mapping(context)

    for name in ('eth', 'wlan'):
        intf_set = set(MacAddr.interface_mapping[name])
        tran_set = set(MacAddr.transient_mapping[name])

        intersection = intf_set & tran_set
        to_remove = intf_set - intersection
        to_add = tran_set - intersection

        if to_remove:
            remove_interfaces(to_remove)

        rationalize(intersection, MacAddr.interface_mapping[name],
                                  MacAddr.transient_mapping[name])
        if to_add:
            logger.info(f"JSE to_add: {to_add}")
            add_interfaces(to_add)
        else:
            logger.info("JSE nothing to add")

def main():
    context = pyudev.Context()

    initialize(context)

    monitor = pyudev.Monitor.from_netlink(context)
    monitor.filter_by('net')
    def interface_event(device):
        logger.info(f"JSE in log_event, device is {device} action is {device.action}")
        mac = None
        intf = None
        if 'ID_NET_NAME_MAC' in device.properties:
            addr = device.properties['ID_NET_NAME_MAC']
            addr = addr[-12:]
        if 'INTERFACE' in device.properties:
            intf = device.properties['INTERFACE']
        action = device.action

        if not addr or not intf:
            return

        mac = MacAddr(addr)

        if action == 'add':
            add_interfaces(set(mac.mac))
        if action == 'remove':
            remove_interfaces(set(mac.mac))

    def sig_handler(signum, frame):
        observer.stop()
        raise KeyboardInterrupt

    signal.signal(signal.SIGTERM, sig_handler)

    observer = pyudev.MonitorObserver(monitor, callback=interface_event)
    observer.start()

    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        logger.info(f"JSE exiting")

if __name__ == '__main__':
    main()
