#!/usr/bin/env python3
#
# Copyright (C) 2020 VyOS maintainers and contributors
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 or later as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#

import os
import sys
import re
import json
import zmq
import logging
import importlib.util

from vyos.config import Config
from vyos.frozen_config import FrozenConfig
from vyos import ConfigError

debug = True

# Configure logging
logger = logging.getLogger(__name__)
# set stream as output
logs_handler = logging.StreamHandler()
logger.addHandler(logs_handler)

if debug:
    logger.setLevel(logging.DEBUG)
else:
    logger.setLevel(logging.INFO)

SOCKET_PATH = "ipc:///run/vyos-configd.sock"

vyos_conf_scripts_dir = '/usr/libexec/vyos/conf_mode'

active_string = ''
session_string = ''

# import conf_mode scripts
# single example for testing
files = ['interfaces-dummy.py']
imports = [os.path.splitext(i)[0] for i in files]
# canonicalize name for loading; we will use 'imports' (previous line)
# for dict keys, however, so as to pass them directly from the node defs
# This is not strictly necessary to load the module, but proper:
module_names = [i.replace('-', '_') for i in imports]
to_load = list(zip(module_names, files))

modules = []

for x in to_load:
    spec = importlib.util.spec_from_file_location(x[0], vyos_conf_scripts_dir + '/' + x[1])
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)
    modules.append(module)

conf_mode_scripts = dict(zip(imports, modules))

def run_script(script, config):
    config.set_level([])
    try:
        c = script.get_config(config)
        script.verify(c)
        script.generate(c)
        script.apply(c)
    except ConfigError as e:
        print(e)

def initialization(socket):
    # Reset config strings:
    active_string = ''
    session_string = ''
    # zmq synchronous for ipc from single client:
    active_string = socket.recv().decode()
    resp = "active"
    socket.send(resp.encode())
    session_string = socket.recv().decode()
    resp = "session"
    socket.send(resp.encode())

    config = FrozenConfig(running_config_text = active_string,
                          session_config_text = session_string)

    return config

def process_node_data(socket, config, data):
    if not config:
        logger.critical(f"Empty config")
        return

    script_name = None

    res = re.match(r'^.+\/([^/].+).py(VYOS_TAGNODE_VALUE=.+)?', data)
    if res.group(1):
        script_name = res.group(1)
    if res.group(2):
        env = res.group(2).split('=')
        os.environ[env[0]] = env[1]

    if not script_name:
        logger.critical(f"Missing script_name")
        return

    run_script(conf_mode_scripts[script_name], config)

if __name__ == '__main__':
    context = zmq.Context()
    socket = context.socket(zmq.REP)

    # Set the right permissions on the socket, then change it back
    o_mask = os.umask(0)
    socket.bind(SOCKET_PATH)
    os.umask(o_mask)

    config = None

    while True:
        #  Wait for next request from client
        msg = socket.recv().decode()
        logger.debug(f"Received message: {msg}")
        message = json.loads(msg)

        if message["type"] == "init":
            resp = "init"
            socket.send(resp.encode())
            config = initialization(socket)
        elif message["type"] == "node":
            process_node_data(socket, config, message["data"])
            resp = "node"
            socket.send(resp.encode())
        else:
            logger.critical(f"Unexpected message: {message}")

