#!/usr/bin/env python3
#
# Copyright (C) 2020 VyOS maintainers and contributors
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 or later as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#

import os
import sys
import re
import json
import logging
import importlib.util
import zmq

from vyos.configsource import ConfigSourceString
from vyos.config import Config
from vyos import ConfigError

debug = True

# Configure logging
logger = logging.getLogger(__name__)
# set stream as output
logs_handler = logging.StreamHandler()
logger.addHandler(logs_handler)

if debug:
    logger.setLevel(logging.DEBUG)
else:
    logger.setLevel(logging.INFO)

SOCKET_PATH = "ipc:///run/vyos-configd.sock"

# Response error codes consistent with vyshim
R_SUCCESS = 1
R_ERROR_COMMIT = 2
R_ERROR_DAEMON = 4
R_PASS = 8

vyos_conf_scripts_dir = '/usr/libexec/vyos/conf_mode'
configd_exclude_file = '/usr/share/vyos/configd-exclude.json'

active_string = ''
session_string = ''

def _key_name_from_file_name(f):
    return os.path.splitext(f)[0]

def _module_name_from_key(k):
    return k.replace('-', '_')

def _path_from_file_name(f):
    return os.path.join(vyos_conf_scripts_dir, f)

# import conf_mode scripts
# single example for testing
files = ['interfaces-dummy.py', 'test_simple.py']
imports = [_key_name_from_file_name(f) for f in files]
# canonicalize name for loading; we will use 'imports' (previous line)
# for dict keys, however, so as to pass them directly from the node defs
# This is not strictly necessary to load the module, but proper:
module_names = [_module_name_from_key(k) for k in imports]
paths = [_path_from_file_name(f) for f in files]
to_load = list(zip(module_names, paths))

modules = []

for x in to_load:
    spec = importlib.util.spec_from_file_location(x[0], x[1])
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)
    modules.append(module)

conf_mode_scripts = dict(zip(imports, modules))

exclude = []

with open(configd_exclude_file) as f:
    exclude_files = json.load(f)

exclude = [_key_name_from_file_name(f) for f in exclude_files]

print(f"JSE --- exclude: {exclude}")

def run_script(script, config) -> int:
    config.set_level([])
    try:
        c = script.get_config(config)
        script.verify(c)
        script.generate(c)
        script.apply(c)
    except ConfigError as e:
        logger.critical(e)
        return R_ERROR_COMMIT

    return R_SUCCESS

def initialization(socket):
    # Reset config strings:
    active_string = ''
    session_string = ''
    # zmq synchronous for ipc from single client:
    active_string = socket.recv().decode()
    resp = "active"
    socket.send(resp.encode())
    session_string = socket.recv().decode()
    resp = "session"
    socket.send(resp.encode())

    configsource = ConfigSourceString(running_config_text=active_string,
                                      session_config_text=session_string)

    config = Config(config_source=configsource)

    return config

def process_node_data(socket, config, data) -> int:
    if not config:
        logger.critical(f"Empty config")
        return R_ERROR_DAEMON

    script_name = None

    res = re.match(r'^.+\/([^/].+).py(VYOS_TAGNODE_VALUE=.+)?', data)
    if res.group(1):
        script_name = res.group(1)
    if res.group(2):
        env = res.group(2).split('=')
        os.environ[env[0]] = env[1]

    if script_name in exclude:
        return R_PASS

    if not script_name:
        logger.critical(f"Missing script_name")
        return R_ERROR_DAEMON

    result = run_script(conf_mode_scripts[script_name], config)

    return result

if __name__ == '__main__':
    context = zmq.Context()
    socket = context.socket(zmq.REP)

    # Set the right permissions on the socket, then change it back
    o_mask = os.umask(0)
    socket.bind(SOCKET_PATH)
    os.umask(o_mask)

    config = None

    while True:
        #  Wait for next request from client
        msg = socket.recv().decode()
        logger.debug(f"Received message: {msg}")
        message = json.loads(msg)

        if message["type"] == "init":
            resp = "init"
            socket.send(resp.encode())
            config = initialization(socket)
        elif message["type"] == "node":
            res = process_node_data(socket, config, message["data"])
            response = res.to_bytes(1, byteorder=sys.byteorder)
            socket.send(response)
        else:
            logger.critical(f"Unexpected message: {message}")
