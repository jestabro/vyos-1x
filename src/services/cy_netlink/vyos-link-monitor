#!/usr/bin/env python3

import os
import socket
import struct
#import cy_netlink
import cy_netlink as nl
#from cy_netlink import RTMGRP_LINK

# These constants map to constants in the Linux kernel. This is a crappy
# way to get at them, but it'll do for now.
#RTMGRP_LINK = 1

#NLMSG_NOOP = 1
#NLMSG_ERROR = 2

#RTM_NEWLINK = 16
#RTM_DELLINK = 17

#IFLA_IFNAME = 3

# Create the netlink socket and bind to RTMGRP_LINK,
s = socket.socket(socket.AF_NETLINK, socket.SOCK_RAW, socket.NETLINK_ROUTE)
s.bind((os.getpid(), nl.RTMGRP_LINK))

while True:
    data = s.recv(65535)
#    print(f"JSE type(data): {type(data)}")
#    msg_len, msg_type, flags, seq, pid = struct.unpack("=LHHLL", data[:16])
    msg_len, msg_type, flags, seq, pid = nl.get_header(data)

    print(f"JSE msg_len: {msg_len}")
    print(f"JSE msg_type: {msg_type}")

    if msg_type == nl.NLMSG_NOOP:
        print("no-op")
        continue
    elif msg_type == nl.NLMSG_ERROR:
        print("error")
        break

    # We are currently monitoring only new or removed links
    if msg_type != nl.RTM_NEWLINK and msg_type != nl.RTM_DELLINK:
        continue

    data = data[16:]

    family, _, if_type, index, flags, change = struct.unpack("=BBHiII", data[:16])

    remaining = msg_len - 32
    data = data[16:]

    while remaining:
#        rta_len, rta_type = struct.unpack("=HH", data[:4])
        rta_len, rta_type = nl.get_rtattr(data[:4])

        # This check comes from RTA_OK, and terminates a string of routing
        # attributes.
        if rta_len < 4:
            break
#        if !RTA_OK(?):
#            break

        rta_data = data[4:rta_len]

        increment = (rta_len + 4 - 1) & ~(4 - 1)
        data = data[increment:]
        remaining -= increment

        # Hoorah, a link is up!
        if rta_type == nl.IFLA_IFNAME:
            if msg_type == nl.RTM_NEWLINK:
                print("New link %s" % rta_data)
            if msg_type == nl.RTM_DELLINK:
                print("Removed link %s" % rta_data)

