#!/usr/share/vyos-http-api-tools/bin/python3
#
# Copyright (C) 2019-2021 VyOS maintainers and contributors
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 or later as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#

import os
import sys
import grp
import json
import traceback
import threading
from functools import wraps
from typing import List, Union

import uvicorn
from fastapi import FastAPI, Form
from fastapi.exceptions import RequestValidationError
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Json

import vyos.config

from vyos.configsession import ConfigSession, ConfigSessionError

DEFAULT_CONFIG_FILE = '/etc/vyos/http-api.conf'
CFG_GROUP = 'vyattacfg'

app = FastAPI(debug=True,
              title="VyOS API",
              version="0.1.0")

# Giant lock!
lock = threading.Lock()

def load_server_config():
    with open(DEFAULT_CONFIG_FILE) as f:
        config = json.load(f)
    return config

def check_auth(key_list, key):
    id = None
    for k in key_list:
        if k['key'] == key:
            id = k['id']
    return id

def error(code, msg):
    resp = {"success": False, "error": msg, "data": None}
    return JSONResponse(resp, status_code=code)

def success(data):
    resp = {"success": True, "data": data, "error": None}
    return JSONResponse(resp)

def auth_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        key = kwargs['key']
        api_keys = app.state.vyos_keys
        id = check_auth(api_keys, key)
        if not id:
            return error(401, "Valid API key is required")
        return f(*args, **kwargs)

    return decorated_function

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request, exc):
    return error(400, str(exc))

# Pydantic models for validation

class ConfigureRequest(BaseModel):
    op: str
    path: List[str]
    value: str = None

class RetrieveRequest(BaseModel):
    op: str
    path: List[str]
    configFormat: str = None

class ConfigFileRequest(BaseModel):
    op: str
    file: str = None

class ImageRequest(BaseModel):
    op: str
    url: str = None
    name: str = None

class GenericRequest(BaseModel):
    op: str
    path: List[str]

@app.post('/configure')
@auth_required
def configure_op(*, key: str = Form(...),
                    data: Json[Union[ConfigureRequest,List[ConfigureRequest]]] = Form(...),
                    strict: str = Form(None)):

    session = app.state.vyos_session
    env = session.get_session_env()
    config = vyos.config.Config(session_env=env)

    if strict == "true":
        strict_bool = True
    else:
        strict_bool = False

    # Allow users to pass just one command
    if not isinstance(data, list):
        data = [data]

    # We don't want multiple people/apps to be able to commit at once,
    # or modify the shared session while someone else is doing the same,
    # so the lock is really global
    lock.acquire()

    status = 200
    error_msg = None
    try:
        for c in data:

            if c.value:
                value = c.value
            else:
                value = ""

            op = c.op
            path = c.path

            if not value:
                value = ""

            # For vyos.configsession calls that have no separate value arguments,
            # and for type checking too
            try:
                cfg_path = " ".join(path + [value]).strip()
            except TypeError:
                raise ConfigSessionError("Malformed command \"{0}\": \"path\" field must be a list of strings".format(json.dumps(c)))

            if op == 'set':
                # XXX: it would be nice to do a strict check for "path already exists",
                # but there's probably no way to do that
                session.set(path, value=value)
            elif op == 'delete':
                if strict_bool and not config.exists(cfg_path):
                    raise ConfigSessionError("Cannot delete [{0}]: path/value does not exist".format(cfg_path))
                session.delete(path, value=value)
            elif op == 'comment':
                session.comment(path, value=value)
            else:
                raise ConfigSessionError("\"{0}\" is not a valid operation".format(op))
        # end for
        session.commit()
        print("Configuration modified via HTTP API using key \"{0}\"".format(id))
    except ConfigSessionError as e:
        session.discard()
        status = 400
        if app.state.vyos_debug:
            print(traceback.format_exc(), file=sys.stderr)
        error_msg = str(e)
    except Exception as e:
        session.discard()
        print(traceback.format_exc(), file=sys.stderr)
        status = 500

        # Don't give the details away to the outer world
        error_msg = "An internal error occured. Check the logs for details."
    finally:
        lock.release()

    if status != 200:
        return error(status, error_msg)
    else:
        return success(None)

@app.post("/retrieve")
@auth_required
def retrieve_op(*, key: str = Form(...), data: Json[RetrieveRequest] = Form(...)):
    session = app.state.vyos_session
    env = session.get_session_env()
    config = vyos.config.Config(session_env=env)

    op = data.op
    path = " ".join(data.path)

    try:
        if op == 'returnValue':
            res = config.return_value(path)
        elif op == 'returnValues':
            res = config.return_values(path)
        elif op == 'exists':
            res = config.exists(path)
        elif op == 'showConfig':
            config_format = 'json'
            if data.configFormat:
                config_format = data.configFormat

            res = session.show_config(path=data.path)
            if config_format == 'json':
                config_tree = vyos.configtree.ConfigTree(res)
                res = json.loads(config_tree.to_json())
            elif config_format == 'json_ast':
                config_tree = vyos.configtree.ConfigTree(res)
                res = json.loads(config_tree.to_json_ast())
            elif config_format == 'raw':
                pass
            else:
                return error(400, "\"{0}\" is not a valid config format".format(config_format))
        else:
            return error(400, "\"{0}\" is not a valid operation".format(op))
    except ConfigSessionError as e:
        return error(400, str(e))
    except Exception as e:
        print(traceback.format_exc(), file=sys.stderr)
        return error(500, "An internal error occured. Check the logs for details.")

    return success(res)

@app.post('/config-file')
@auth_required
def config_file_op(*, key: str = Form(...), data: Json[ConfigFileRequest] = Form(...)):
    session = app.state.vyos_session

    op = data.op

    try:
        if op == 'save':
            if data.file:
                path = data.file
            else:
                path = '/config/config.boot'
            res = session.save_config(path)
        elif op == 'load':
            if data.file:
                path = data.file
            else:
                return error(400, "Missing required field \"file\"")
            res = session.migrate_and_load_config(path)
            res = session.commit()
        else:
            return error(400, "\"{0}\" is not a valid operation".format(op))
    except ConfigSessionError as e:
        return error(400, str(e))
    except Exception as e:
        print(traceback.format_exc(), file=sys.stderr)
        return error(500, "An internal error occured. Check the logs for details.")

    return success(res)

@app.post('/image')
@auth_required
def image_op(*, key: str = Form(...), data: Json[ImageRequest] = Form(...)):
    session = app.state.vyos_session

    op = data.op

    try:
        if op == 'add':
            if data.url:
                url = data.url
            else:
                return error(400, "Missing required field \"url\"")
            res = session.install_image(url)
        elif op == 'delete':
            if data.name:
                name = data.name
            else:
                return error(400, "Missing required field \"name\"")
            res = session.remove_image(name)
        else:
            return error(400, "\"{0}\" is not a valid operation".format(op))
    except ConfigSessionError as e:
        return error(400, str(e))
    except Exception as e:
        print(traceback.format_exc(), file=sys.stderr)
        return error(500, "An internal error occured. Check the logs for details.")

    return success(res)

@app.post('/generate')
@auth_required
def generate_op(*, key: str = Form(...), data: Json[GenericRequest] = Form(...)):
    session = app.state.vyos_session

    op = data.op
    path = data.path

    if not isinstance(path, list):
        return error(400, "Malformed command: \"path\" field must be a list of strings")

    try:
        if op == 'generate':
            res = session.generate(path)
        else:
            return error(400, "\"{0}\" is not a valid operation".format(op))
    except ConfigSessionError as e:
        return error(400, str(e))
    except Exception as e:
        print(traceback.format_exc(), file=sys.stderr)
        return error(500, "An internal error occured. Check the logs for details.")

    return success(res)

@app.post('/show')
@auth_required
def show_op(*, key: str = Form(...), data: Json[GenericRequest] = Form(...)):
    session = app.state.vyos_session

    op = data.op
    path = data.path

    if not isinstance(path, list):
        return error(400, "Malformed command: \"path\" field must be a list of strings")

    try:
        if op == 'show':
            res = session.show(path)
        else:
            return error(400, "\"{0}\" is not a valid operation".format(op))
    except ConfigSessionError as e:
        return error(400, str(e))
    except Exception as e:
        print(traceback.format_exc(), file=sys.stderr)
        return error(500, "An internal error occured. Check the logs for details.")

    return success(res)

if __name__ == '__main__':
    # systemd's user and group options don't work, do it by hand here,
    # else no one else will be able to commit
    cfg_group = grp.getgrnam(CFG_GROUP)
    os.setgid(cfg_group.gr_gid)

    # Need to set file permissions to 775 too so that every vyattacfg group member
    # has write access to the running config
    os.umask(0o002)

    try:
        server_config = load_server_config()
    except Exception as e:
        print("Failed to load the HTTP API server config: {0}".format(e))

    session = ConfigSession(os.getpid())

    app.state.vyos_session = session
    app.state.vyos_keys = server_config['api_keys']
    app.state.vyos_debug = server_config['debug']

    try:
        uvicorn.run(app, host=server_config["listen_address"],
                         port=int(server_config["port"]),
                         proxy_headers=True)
    except OSError as e:
        print(f"OSError {e}")
