#!/usr/bin/env python3
#
# Copyright (C) 2021 VyOS maintainers and contributors
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 or later as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#

import os
import socket
import logging
import argparse
from queue import Queue
from threading import Thread
from typing import Callable

import vyos.netlink as nl
from vyos.nl_event import NL_Event, NL_Message, action_on_event

logger = logging.getLogger(__name__)
logs_handler = logging.StreamHandler()
logger.addHandler(logs_handler)

def update_status(s: int, d: bytes, leng: int, align: Callable) -> tuple[int, bytes]:
    step = align(leng)
    s -= step
    d = d[step:]
    return s, d

def parse_rtattr(buf: bytes, max_attr: int) -> dict:
    attrs = {}
    remaining = len(buf)
    while remaining:
        attr = nl.get_rtattr(buf)
        if not nl.Rta_Ok(attr, remaining):
            break

        rta_type = attr['rta_type']
        rta_len = attr['rta_len']

        struct_size = nl.Rta_Length(0)

        rta = nl.Rta_Data(buf, rta_len)

        print(f"JSE internal: {rta}")
        print(f"JSE explicit: {buf[struct_size: rta_len]}")

        if rta_type <= max_attr:
#            attrs[rta_type] = rta
            attrs[rta_type] = buf[struct_size: rta_len]

        # Here we would prefer to use a suitably wrapped RTA_NEXT, however,
        # the macro updates length in place, requiring a pass-by-reference;
        # the obvious workaround of returning a tuple is not supported by
        # Cython for tuples containing a python _object_ (bytes). So, we do
        # it explicitly instead of contriving a pass-by-reference.
        remaining, buf = update_status(remaining, buf, rta_len, nl.Rta_Align)

    return attrs

def nl_receive(out_q: Queue):
    try:
        s = socket.socket(socket.AF_NETLINK, socket.SOCK_RAW, socket.NETLINK_ROUTE)
#        s.bind((os.getpid(), nl.RTMGRP_LINK | nl.RTMGRP_IPV4_IFADDR))
        s.bind((os.getpid(), nl.RTNLGRP_LINK | nl.RTNLGRP_IPV4_IFADDR | nl.RTNLGRP_IPV6_IFADDR))
    except OSError as e:
        logger.critical(f"OSError {e}")

    while True:
        data: bytes = s.recv(65535)
        status: int = len(data)
        nlmsg_hdrlen: int = nl.NLMSG_HDRLEN

        while status >= nlmsg_hdrlen:
            nlh: nl.nlmsghdr = nl.get_header(data)
            nlmsg_type: int = nlh['nlmsg_type']
            nlmsg_len: int = nlh['nlmsg_len']

            if nlmsg_type == nl.NLMSG_NOOP:
                logger.info("netlink message type is NLMSG_NOOP")
                status, data = update_status(status, data, nlmsg_len, nl.Nlmsg_Align)
                continue
            if nlmsg_type == nl.NLMSG_ERROR:
                logger.critical("netlink message type is NLMSG_ERROR")
                break

            ifinfo_data = nl.Nlmsg_Data(data)
            ifi_type, ifi_index, ifi_flags, ifi_change = nl.get_ifinfomsg(ifinfo_data)

            logger.debug(f"ifi_type: {ifi_type}, ifi_index: {ifi_index}, ifi_flags: {ifi_flags}, ifi_change: {ifi_change}")

            rta_data = nl.Ifla_Rta(ifinfo_data)
            attr_dict = parse_rtattr(rta_data, nl.IFLA_MAX)

            if nl.IFLA_IFNAME in list(attr_dict):
                ifName = attr_dict[nl.IFLA_IFNAME].decode().rstrip('\0')
            else:
                ifName = ''

            if nl.IFLA_OPERSTATE in list(attr_dict):
                ifOperState = attr_dict[nl.IFLA_OPERSTATE].decode().rstrip('\0')
            else:
                ifOperState = ''

            ifUp = bool(ifi_flags & nl.IFF_UP)
            ifRunning = bool(ifi_flags & nl.IFF_RUNNING)

            ifUp_changed = bool(ifi_change & nl.IFF_UP)
            ifRunning_changed = bool(ifi_change & nl.IFF_RUNNING)

            logger.debug(f"ifname: {ifName} ifup: {ifUp} ifrunning: {ifRunning}")

            ifaddr_data = nl.Nlmsg_Data(data)
            rta_data = nl.Ifa_Rta(ifaddr_data)
            attr_dict = parse_rtattr(rta_data, nl.IFA_MAX)

            if nl.IFA_LOCAL in list(attr_dict):
                ifAddress = socket.inet_ntop(socket.AF_INET, attr_dict[nl.IFA_LOCAL])
            else:
                ifAddress = ''

            logger.debug(f"ifaddress: {ifAddress}")

            if nlmsg_type == nl.RTM_NEWLINK:
                msg = NL_Message(event=NL_Event.NEWLINK, ifname=ifName,
                                 ifaddress=ifAddress, ifup=ifUp,
                                 ifrunning=ifRunning,
                                 ifup_changed=ifUp_changed,
                                 ifrunning_changed=ifRunning_changed,
                                 ifoperstate=ifOperState)
                msg.text = "newlink event"
                out_q.put(msg)
            elif nlmsg_type == nl.RTM_DELLINK:
                msg = NL_Message(event=NL_Event.DELLINK, ifname=ifName,
                                 ifaddress=ifAddress, ifup=ifUp,
                                 ifrunning=ifRunning,
                                 ifup_changed=ifUp_changed,
                                 ifrunning_changed=ifRunning_changed,
                                 ifoperstate=ifOperState)
                msg.text = "dellink event"
                out_q.put(msg)
            elif nlmsg_type == nl.RTM_NEWADDR:
                msg = NL_Message(event=NL_Event.NEWADDR, ifname=ifName,
                                 ifaddress=ifAddress, ifup=ifUp,
                                 ifrunning=ifRunning,
                                 ifup_changed=ifUp_changed,
                                 ifrunning_changed=ifRunning_changed,
                                 ifoperstate=ifOperState)
                msg.text = "newaddr event"
                out_q.put(msg)
            elif nlmsg_type == nl.RTM_DELADDR:
                msg = NL_Message(event=NL_Event.DELADDR, ifname=ifName,
                                 ifaddress=ifAddress, ifup=ifUp,
                                 ifrunning=ifRunning,
                                 ifup_changed=ifUp_changed,
                                 ifrunning_changed=ifRunning_changed,
                                 ifoperstate=ifOperState)
                msg.text = "deladdr event"
                out_q.put(msg)

            status, data = update_status(status, data, nlmsg_len, nl.Nlmsg_Align)

def nl_action(in_q: Queue):
    @action_on_event(NL_Event.NEWLINK)
    def on_newlink():
        logger.info("JSE callback on newlink")

    @action_on_event(NL_Event.DELLINK)
    def on_dellink():
        logger.info("callback on dellink")

    while True:
        msg = in_q.get()
        logger.info(f"msg is {vars(msg)}")
        msg.run_actions()

def main():
    argparser = argparse.ArgumentParser()
    argparser.add_argument('--debug', action='store_true')
    args = argparser.parse_args()

    if args.debug:
        logger.setLevel(logging.DEBUG)
    else:
        logger.setLevel(logging.INFO)

    q = Queue()
    t1 = Thread(target=nl_action, args=(q, ))
    t2 = Thread(target=nl_receive, args=(q, ))
    t1.start()
    t2.start()

if __name__ == '__main__':
    main()
